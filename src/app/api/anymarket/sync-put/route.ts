import { NextRequest, NextResponse } from 'next/server';
import { executeQuery } from '@/lib/database';

// Fun√ß√£o auxiliar para salvar logs de sincroniza√ß√£o
async function saveSyncLog(productId: number, anymarketId: string, title: string, description: string, success: boolean, responseData: any, errorMessage?: string, syncType: string = 'patch', action: string = 'update') {
  try {
    const logQuery = `
      INSERT INTO anymarket_sync_logs (product_id, anymarket_id, title, description, success, response_data, error_message, sync_type, action, created_at)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())
    `;

    await executeQuery(logQuery, [
      productId,
      anymarketId,
      title,
      description,
      success ? 1 : 0,
      JSON.stringify(responseData),
      errorMessage || null,
      syncType,
      action
    ]);

    console.log('üìù Log de sincroniza√ß√£o salvo com sucesso');
  } catch (error) {
    console.error('‚ùå Erro ao salvar log de sincroniza√ß√£o:', error);
  }
}

export async function PUT(request: NextRequest) {
  return handleRequest(request);
}

export async function POST(request: NextRequest) {
  return handleRequest(request);
}

async function handleRequest(request: NextRequest) {
  try {
    // Verificar se h√° conte√∫do no body
    const requestText = await request.text();
    console.log('üìÑ Request body bruto:', requestText);
    
    if (!requestText || requestText.trim() === '') {
      console.log('‚ö†Ô∏è Request body vazio');
      return NextResponse.json({
        success: false,
        message: 'Request body vazio',
        error: 'Empty request body'
      }, { status: 400 });
    }
    
    let requestData;
    try {
      requestData = JSON.parse(requestText);
    } catch (parseError) {
      console.error('‚ùå Erro ao fazer parse do request body:', parseError);
      console.log('üìÑ Conte√∫do que causou erro:', requestText);
      return NextResponse.json({
        success: false,
        message: 'Erro ao fazer parse do request body',
        error: parseError instanceof Error ? parseError.message : 'Parse error'
      }, { status: 400 });
    }
    
    const { productId } = requestData;

    if (!productId) {
      return NextResponse.json({
        success: false,
        message: 'ID do produto √© obrigat√≥rio'
      }, { status: 400 });
    }

    console.log('üîÑ Iniciando sincroniza√ß√£o PUT com Anymarket...');
    console.log('üìã Product ID:', productId);

    // 1. Buscar produto na tabela anymarket com t√≠tulo
    const productQuery = `
      SELECT 
        a.ref_produto_vtex,
        a.id_produto_any as anymarket_id,
        p.name as product_name,
        t.title as product_title
      FROM anymarket a
      INNER JOIN products_vtex p ON a.ref_produto_vtex = p.ref_produto
      LEFT JOIN titles t ON p.id_produto_vtex = t.id_product_vtex
      WHERE p.id_produto_vtex = ?
    `;
    
    const products = await executeQuery(productQuery, [productId]);
    
    if (!products || products.length === 0) {
      return NextResponse.json({
        success: false,
        message: 'Produto n√£o encontrado na tabela anymarket'
      }, { status: 404 });
    }

    const product = products[0];
    console.log('‚úÖ Produto encontrado:', {
      ref_produto_vtex: product.ref_produto_vtex,
      anymarket_id: product.anymarket_id,
      product_name: product.product_name,
      product_title: product.product_title
    });

    // 2. Fazer GET para recuperar payload completo do Anymarket
    console.log('üîç Recuperando payload completo do Anymarket...');
    let anymarketPayload: any = {};
    
    try {
      console.log('üåê Fazendo GET para AnyMarket:', `https://api.anymarket.com.br/v2/products/${product.anymarket_id}`);
      console.log('üîë Token AnyMarket configurado:', process.env.ANYMARKET ? 'Sim' : 'N√£o');
      
      const getResponse = await fetch(`https://api.anymarket.com.br/v2/products/${product.anymarket_id}`, {
        method: 'GET',
        headers: {
          'gumgaToken': process.env.ANYMARKET || '',
          'Content-Type': 'application/json',
          'User-Agent': 'Meli-Integration/1.0',
          'Accept': 'application/json'
        },
        cache: 'no-store'
      });
      
      console.log('üì° Status da resposta AnyMarket:', getResponse.status);
      console.log('üì° Headers da resposta:', Object.fromEntries(getResponse.headers.entries()));

      if (getResponse.ok) {
        const responseText = await getResponse.text();
        console.log('üìÑ Resposta bruta do AnyMarket:', responseText);
        
        if (!responseText || responseText.trim() === '') {
          console.log('‚ö†Ô∏è Resposta vazia do AnyMarket');
          return NextResponse.json({
            success: false,
            message: 'Resposta vazia do AnyMarket',
            error: 'Empty response from AnyMarket API'
          }, { status: 500 });
        }
        
        try {
          anymarketPayload = JSON.parse(responseText);
          console.log('‚úÖ Payload completo recuperado com sucesso');
          console.log('üìä Payload recuperado:', {
            id: anymarketPayload.id,
            title: anymarketPayload.title,
            category: anymarketPayload.category,
            priceFactor: anymarketPayload.priceFactor,
            total_fields: Object.keys(anymarketPayload).length
          });
          
          // Mostrar o payload completo recuperado
          console.log('üîç PAYLOAD COMPLETO RECUPERADO DO ANYMARKET:');
          console.log(JSON.stringify(anymarketPayload, null, 2));
        } catch (parseError) {
          console.error('‚ùå Erro ao fazer parse do JSON:', parseError);
          console.log('üìÑ Conte√∫do que causou erro:', responseText);
          return NextResponse.json({
            success: false,
            message: 'Erro ao fazer parse da resposta do AnyMarket',
            error: parseError instanceof Error ? parseError.message : 'Parse error'
          }, { status: 500 });
        }
      } else {
        console.log('‚ùå Erro ao recuperar payload:', getResponse.status);
        return NextResponse.json({
          success: false,
          message: 'Erro ao recuperar payload do Anymarket',
          error: `Status: ${getResponse.status}`
        }, { status: getResponse.status });
      }
    } catch (getError) {
      console.error('‚ùå Erro ao recuperar payload:', getError);
      return NextResponse.json({
        success: false,
        message: 'Erro ao recuperar payload do Anymarket',
        error: getError instanceof Error ? getError.message : 'Erro desconhecido'
      }, { status: 500 });
    }

    console.log('‚úÖ GET realizado com sucesso - payload recuperado');

    // 3. Criar payload simplificado removendo characteristics
    console.log('üßπ Criando payload simplificado removendo characteristics...');
    
    // Extrair apenas os campos b√°sicos que a API aceita (sem SKUs e sem characteristics)
    const productTitle = product.product_title || 'Produto Gen√©rico'; // T√≠tulo da tabela titles
    const simplifiedPayload = {
      id: anymarketPayload.id,
      title: productTitle, // T√≠tulo da tabela titles
      description: anymarketPayload.description || '',
      category: anymarketPayload.category || null,
      brand: anymarketPayload.brand || null,
      model: anymarketPayload.model || null,
      gender: anymarketPayload.gender || null,
      warrantyTime: anymarketPayload.warrantyTime || 1,
      warrantyText: anymarketPayload.warrantyText || 'Garantia de F√°brica',
      priceFactor: anymarketPayload.priceFactor || 1,
      calculatedPrice: anymarketPayload.calculatedPrice || false,
      definitionPriceScope: anymarketPayload.definitionPriceScope || 'COST'
      // SKUs removidos - s√≥ podem ser atualizados via API espec√≠fica
      // characteristics removidas - ser√£o removidas no PATCH
    };
    
    console.log('‚úÖ Payload simplificado criado (sem SKUs e sem characteristics)');

    // 4. Fazer PATCH para o Anymarket com payload simplificado
    console.log('üì§ Enviando payload SIMPLIFICADO para Anymarket via PATCH:', {
      id: simplifiedPayload.id,
      title: simplifiedPayload.title,
      total_fields: Object.keys(simplifiedPayload).length,
      strategy: 'get_completo_e_patch_simplificado'
    });

    console.log('üåê Fazendo requisi√ß√£o PATCH para Anymarket API...');
    console.log('üîó URL:', `https://api.anymarket.com.br/v2/products/${product.anymarket_id}`);
    console.log('üìã Payload simplificado:', JSON.stringify(simplifiedPayload, null, 2));

    const anymarketResponse = await fetch(`https://api.anymarket.com.br/v2/products/${product.anymarket_id}`, {
      method: 'PATCH',
      headers: {
        'gumgaToken': process.env.ANYMARKET || '',
        'Content-Type': 'application/merge-patch+json',
        'User-Agent': 'Meli-Integration/1.0',
        'Accept': 'application/json'
      },
      body: JSON.stringify(simplifiedPayload),
      cache: 'no-store'
    });

    const anymarketResult = await anymarketResponse.json();

    if (!anymarketResponse.ok) {
      console.error('‚ùå Erro na resposta do Anymarket:', {
        status: anymarketResponse.status,
        result: anymarketResult
      });

      // Log de erro salvo
      await saveSyncLog(
        productId,
        product.anymarket_id,
        product.product_title || product.product_name,
        '',
        false,
        anymarketResult,
        `Erro HTTP ${anymarketResponse.status}: ${JSON.stringify(anymarketResult)}`,
        'patch',
        'update'
      );

      return NextResponse.json({
        success: false,
        message: 'Erro ao sincronizar com Anymarket via PATCH',
        error: anymarketResult
      }, { status: anymarketResponse.status });
    }

    console.log('‚úÖ Sincroniza√ß√£o PATCH com Anymarket realizada com sucesso!');

    // 4. Atualizar enviado_any na tabela anymarket (removido data_sincronizacao)
    try {
      await executeQuery(`
        UPDATE anymarket
        SET enviado_any = CURRENT_TIMESTAMP,
            updated_at = CURRENT_TIMESTAMP
        WHERE ref_produto_vtex = ?
      `, [product.ref_produto_vtex]);
      console.log('üìÖ Data de envio atualizada na tabela anymarket');
    } catch (updateError) {
      console.error('‚ö†Ô∏è Erro ao atualizar data de envio (n√£o cr√≠tico):', updateError);
    }

    // 5. Log de sincroniza√ß√£o salvo
    await saveSyncLog(
      productId,
      product.anymarket_id,
      product.product_title || product.product_name,
      '',
      true,
      anymarketResult,
      undefined,
      'patch',
      'update'
    );

    return NextResponse.json({
      success: true,
      message: 'Produto sincronizado com sucesso no Anymarket (t√≠tulo da tabela titles + characteristics removidas)',
      data: {
        product_id: productId,
        anymarket_id: product.anymarket_id,
        product_name: product.product_name,
        payload_title: productTitle,
        payload_fields: Object.keys(simplifiedPayload).length,
        characteristics_removed: anymarketPayload.characteristics ? anymarketPayload.characteristics.length : 0,
        original_payload: anymarketPayload, // Payload original recuperado do GET
        simplified_payload: simplifiedPayload, // Payload simplificado enviado no PATCH
        sync_type: 'get_and_patch_with_titles_table_remove_characteristics',
        sync_timestamp: new Date().toISOString()
      }
    });

  } catch (error: any) {
    console.error('‚ùå Erro interno do servidor:', error);
    
    // Log de erro interno
    try {
      await saveSyncLog(
        0, // productId n√£o dispon√≠vel em caso de erro interno
        '',
        '',
        '',
        false,
        { error: error.message, stack: error.stack },
        `Erro interno: ${error.message}`,
        'patch',
        'update'
      );
    } catch (logError) {
      console.error('‚ùå Erro ao salvar log de erro interno:', logError);
    }
    
    return NextResponse.json({
      success: false,
      message: 'Erro interno do servidor ao sincronizar com Anymarket via PATCH',
      error: error.message
    }, { status: 500 });
  }
}